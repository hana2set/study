# 그래프
## 트리
부모와 자식으로 이루어진 계층적 추상 데이터 유형
- 순환(cycle) 없는 하나의 연결 그래프
- 정점이 N개, 간선이 N-1개
- 두 정점에 대한 경로가 유일하다.
- 요소
  - `루트 노드`: 최상위 노드
  - `부모 노드`
  - `자식 노드`
  - `잎 노드(리프 노드)`: 자식이 없는 노드
  - `내부 노드(인터널 노드)`: 잎노드가 아닌 노드

### 이진 트리
각각의 노드가 최대 두 개의 자식 노드를 가지는 트리 자료 구조

- 순회 종류
  - 전위 순회: ROOT - L - R
  - 중위 순회: L - ROOT - R
  - 후위 순회: L - R - ROOT

### 신장 트리 (spanning tree)
주어진 그래프에서 모든 노드를 포함하면서 사이클이 없는 연결 **부분 그래프**
- 형태상으로 트리 구조의 설명과 같음
  - 뉘앙스로 구분 (형태가 아닌 **용도에 따른 구분으로 보는 것이 좋음**)
  - 루트 노드 없음

#### 최소 스패닝 트리 (MST)
부분 그래프 중 가중치 합이 최소인 신장 트리를 의미

### 트라이(Trie)
![Image](https://github.com/user-attachments/assets/4462513d-0bae-40eb-9580-f65ddead04d0)
- 문자열을 저장하고 빠르게 탐색하기 위한 트리 형태의 자료구조
- **자동완성 기능, 사전 검색** 등 문자열을 탐색하는데 특화
- `래딕스 트리`(radix tree), `접두사 트리`(prefix tree), `탐색 트리`(retrieval tree) 라고도 불림
- 장점
  1. 문자열 검색이 빠름
  2. 시간 복잡도가 효율적
- 단점
  1. 저장 공간이 크다 (i.e. 메모리가 비효율적) (각 노드가 포인터를 배열로 가져야 해서)

- 참고: https://innovation123.tistory.com/116

### 세그먼트 트리 (Segment Tree)
- 이진 트리 형태로, 구간의 합(또는 최솟값, 최댓값, 곱 등)을 **빠르게** 구하는 데 사용하는 자료구조
- 시간복잡도(조회, 수정): O(logN)
![Image](https://github.com/user-attachments/assets/43fc2d6a-578b-4107-9305-f2909e6907a3)

<details>
  <summary>구현</summary>

- 트리 생성
  - 구간을 반으로 나누면서, 구간합을 제귀적으로 계산
    ```java
      public long init(int start, int end, int node) {
        if (start == end) {
          return tree[node] = arr[start];
        }
        int mid = (start + end) / 2;

        // 재귀적으로 두 부분으로 나눈 뒤에 그 합을 자기 자신으로 함.
        return tree[node] = init(start, mid, node * 2) + init(mid + 1, end, node * 2 + 1);
      }

    ```
- 구간합 계산
  - 트리를 내려가며 구간 범위 안에 있는 값을 모두 더함
- 원소값 수정
  - 트리를 내려가며 구간 범위 안에 있는 값을 변경할 값과의 차이만큼 수정

</details>


- 참고: https://wikidocs.net/209446

#### lazy propagation
#### 펜윅 트리 (Fenwick Tree)
- **구간 합을 빠르게** 연산하기 위해 고안된 자료 구조.
- 이진 인덱스 트리 (Binary Indexed Tree) 라고도 함.
- 세그먼트 트리에서 **짝수 인덱스를 무시한** 트리 구조
- 장점: 좀 더 적은 메모리와 간단한 코드 (구간의 길이 N)
- 구간 합의 변경이 필요하면 `펜윅 트리` > `누적합 알고리즘`
- ![image](https://github.com/user-attachments/assets/716efa67-4111-4074-b41a-7614fb118849)
- 참고: [백준 16975](https://www.acmicpc.net/problem/16975)
- [펜윅 트리](https://nahwasa.com/entry/%ED%8E%9C%EC%9C%85-%ED%8A%B8%EB%A6%ACFenwick-tree-BIT-%EA%B8%B0%EB%B3%B8-2D-lazy-propagationrange-update-point-query-range-update-range-query)
- 사용방법
  - 구간의 길이
    - 이진수 표현의 오른쪽 끝에 있는 0의 갯수
      - `10`: 1010(2) -> 0의 갯수가 1개임으로, tree[10]은 `2^1`개 숫자의 합
  - 구간합 찾기
    - 이진수 표현의 가장 오른쪽 1인 비트를 지우면서, 각 트리를 합함
      - `psum[10]`: 10 = 1010(2) -> tree[1010(2)] + tree[1000(2)] = `tree[10]+tree[8]`
  - 배열 값 변경
    - 이진수 표현의 가장 오른쪽 1인 비트에 1씩 더해주며, 해당 트리를 diff만큼 더함
      - `arr[5] += 3`: 5 = 0101(2) -> 0101(2), 0110(2), 1000(2) -> `tree[5] += 3, tree[6] += 3, tree[8] += 3`
    - 
> 이진수에서 가장 오른쪽 1을 계산하는 방법
> `num & -num`
> 음수는 2의 보수를 사용함으로, 음수와 양수를 AND(&)연산하면, 원래 값의 가장 오른쪽 1의 위치를 알 수 있다.

## 방향 그래프
### 강한 연결 요소 (SCC, strongly connected component)
- 내부에서 자유롭게 이동이 가능한 최대 크기의 노드 집합
  1. 한 scc안에 속한 임의의 어떤 한 노드 A와 다른 한 임의의 노드 B에 대해서 A에서 B로 갈 수 있는 경로가 존재한다.
  2. 어떠한 scc에 속하지 않은 어떠한 노드도 scc에 추가로 들어왔을 때 1의 성질을 만족하면 안된다.
-  모든 방향그래프는 SCC들의 위상정렬로 나타낼 수 있다.
- 구하는 방법
  - 코사라주 알고리즘
    1. 주어진 그래프의 **역방향 그래프**를 계산
    2. DFS를 통해 원본 그래프의 종료 지점을 스택에 추가
    3. 스택에서 지점을 뽑으며 역방향 그래프의 DFS를 수행
    4. 해당 DFS 수행하며 방문한 모든 점이 각자 SCC
  - 타잔 알고리즘

# 테이블
## 희소 테이블 (Sparse table)
- 배열 내 구간의 쿼리를 빠르게 수행할 수 있는 자료구조
- 노드에서 나가는 간선이 하나일 경우 사용 가능 (결합법칙 성립 -> 제곱수를 미리 계산해둠)
- 세그먼트 트리랑 유사 (차이: 희소 테이블은 변경 불가능)
- 시간복잡도: 전처리 O(NlogN), 쿼리 당 O(logN)
- 사용 방법:
  1. 2차원 배열을 만들고 제곱 차수에 따른 결과값을 미리 계산 (전처리)
  2. 구하고자 하는 횟수를 2로 나누며 (또는 비트 연산) 테이블에서 연산된 값을 차례로 계산
- 참고: [백준 17435번](https://www.acmicpc.net/problem/17435)

  


  <!-- https://wikidocs.net/ -->