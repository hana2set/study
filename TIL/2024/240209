답변의 내용이 크게 이해되지 않습니다. 본 질문의 요지는, 데이터 정합성을 어떤 방법을 이용하여 보장하고 있는가?를 물어보는 내용으로 
적어도 트랜잭션 혹은 락을 기반으로 답변이 설명되어야 해보입니다.

한 가지 예시를 들어, 2024년 1월 29일 19시에 방 A라고 하는 남은 예약 자리가 1개일 때 
동시에 5명의 유저가 방 A에 예약 요청을 보냈을 때의 상황을 가정해보도록 합시다.

 그렇다면, 5개의 트랜잭션이 동시에 "방"이라는 테이블에 접근하고 방에 대한 정보를 읽을 것입니다.
(S-Lock) 이 상황에서 아직 방 A에 대한 예약 기록이 없는 상태이므로, 5개의 트랜잭션은 모두 동시에 Write 요청을 보낼 것 입니다.
(X-Lock) 여기서 별도의 처리를 하지 않았다면, 아마 트랜잭션 5개가 모두 성공한 것으로 나올 것 이며,
이는 사용자 입장에서 분명 예약하고 돈까지 나갔는데, 예약자는 다른 사람 혹은 여러 명으로 출력될 수 있습니다. 
이 상황에서, 딱 한 명의 사용자에게만 예약이 성공하려면 어떻게 해야 하는지에 대해서 고민해보고 다시 답변 해보시기 바랍니다.

-> 사실 현업에서는 CQRS 라는 방식으로 조회와 저장 서비스를 아예 분리하고, 
저장 서비스 앞단에 메시지 큐를 두어 데이터 정합성을 보장하는 방법이 주로 사용되고 있습니다. 
여기서 더 나아가, 메시지 큐에 들어가는 데이터를 최소한으로 구성 
(예를 들어, user id와 reservation id만 메시지 큐에 삽입)하여 
일부러 데이터 조회하는 서비스를 강제로 거치도록 하여 검증하는 방식도 있습니다. 
(user와 reservation의 세부 정보를 얻으려면 반드시 해당 서비스를 통해야 함.) 이를 zero-payload 라고 합니다. 
(사실 zero-payload는 데이터 정합성 이슈 보다는 메시지 큐에 들어가는 데이터 포맷을 일치 시키기 위해서 주로 사용하는 방법인데... 
이를 활용해서도 데이터 정합성 해결을 시도해볼만 하다는 것을 이야기 드리는 것이므로 참고만 하시면 좋겠습니다.)
 


자료구조
알고리즘


카프카

msa 방식에서 많이 사용합니다.


api cache

api 

카프카 의존성 떨어트릴려오
팀 나누려고.

쿠키

브라우저안에 종속하면 주의


 TIL 내용 aws/EC2 (Elastic Compute Cloud).md 이관