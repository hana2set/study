최빈 질문

# RDBMS 
관계형 데이터베이스의 약어로 
스키마라는 데이터 규칙을 통해 테이블이라는 표 형식에 저장하는 시스템을 의미합니다.
<!-- 데이터 무결성, 일관성 등의 장점들 떄문에 데이터 관리가 쉽고 
직접 관리해야하는 파일시스템에 비해 개발비용이 현저히 적기때문에 많이 사용합니다. -->
구조화된 데이터와 복잡한 쿼리, 특히 조인 연산을 통한 데이터 관계 분석에 강점을 가집니다. 데이터의 중복을 방지하고, 외래키를 통해 데이터 간의 관계를 명확히 할 수 있습니다. 또한, ACID(원자성, 일관성, 고립성, 지속성) 트랜잭션의 특성으로 데이터의 무결성과 일관성을 보장합니다.

<!-- 다만 기본적으로 무겁고 복잡한 단점이 있고 
특히 현재 큰 데이터에 대한 빠른 처리 속도 요구에 따라 
RDBMS보다 안정성은 떨어지지만 빠른 NoSQL과 병행하여 사용하는 추세입니다.  -->


# nosql 
Not Only Sql의 약자로 RDB가 아닌 데이터 저장 기술을 의미합니다. 
빅데이터와 대용량 트래픽에 대응하기 위해 나왔기 때문에 데이터 일관성을 어느정도 포기하고 
정해지지않은 규격의 데이터 유형으로 저장합니다. 
대표적으로 document형태인 mongoDB, key-value 형태인 redis 등이 있습니다.
구조가 유연하고 분산 처리도 용이한 장점이 있지만 
그룹 형태로 저장하기 때문에 데이터 중복에 대한 삭제가 어렵고 (update가 느림)
명확한 데이터 구조를 보장하지 않기 때문에 구조를 결정해야할 경우 어려울 수 있습니다.


# mvc 
MVC 패턴은 Model-View-Controller의 약자로, 애플리케이션을 세 부분으로 나누어 설계하는 디자인 패턴입니다.
컨트롤러가 사용자의 요청을 받아 해당 요청에 맞는 모델의 데이터 처리를 지시합니다.
모델은 필요한 데이터 작업을 수행하고 결과를 컨트롤러에 반환합니다.
컨트롤러는 이 데이터를 받아 적절한 뷰를 선택하고, 뷰는 최종적으로 사용자에게 결과를 표시합니다. 이 패턴은 각 단계에서 데이터가 어떻게 처리되고 전달되는지 명확히 하여, 애플리케이션의 관리와 확장을 용이하게 합니다.
<!-- Model, View, Controller 로 관심사를 분리하는 디자인 패턴입니다.
model은 데이터와 비즈니스 로직을 관리하고
view는 화면 처리를 담당합니다.
controller는 해당 데이터를 전달하는 역할을 맡습니다. -->

# RDBMS의 정규화
RDBMS에서 정규화는 데이터베이스 구조를 최적화하기 위해 데이터를 조직하는 프로세스입니다. 목표는 데이터 중복을 최소화하고, 데이터 무결성을 유지하는 것입니다.

제1정규형에 대해 말씀드리겠습니다. 테이블의 모든 컬럼이 원자값을 가져야 합니다. 즉, 각 컬럼에는 반복되는 그룹이나 다중 값을 포함할 수 없습니다.

제2정규형. 모든 비기본 키 속성이 기본 키에 완전 함수적 종속을 가져야 합니다. 이는 부분적 종속을 제거하여 데이터 중복을 줄이고, 데이터의 논리적 구조를 강화하는 데 도움을 줍니다.

제3정규형에 대해 말씀드리겠습니다. 어떤 비기본 키 속성도 기본 키에만 종속되어야 하며, 기본 키가 아닌 다른 속성에 의존해서는 안 됩니다. 이를 통해 이행적 종속성을 제거합니다.

BCNF는 더 엄격한 3NF로, 모든 결정자가 후보 키여야 합니다.

정규화는 데이터의 일관성과 무결성을 유지하고, 데이터베이스를 업데이트할 때 발생할 수 있는 오류를 방지하는 데 중요합니다. 이는 모델링 능력을 향상시키며, 복잡한 데이터 구조에서도 효과적인 데이터 관리 전략을 개발할 수 있게 합니다.

<!-- 데이터의 중복을 제거하고 데이터의 무결성을 유지하는 작업입니다. -->

# Primary Key, Foreign Key
pk는 기본키로 테이블의 각 데이터를 식별하는 용도로 사용되며 unique하며 nullable하지 않습니다.
fk는 다른테이블의 pk를 참조하는 키 입니다.

# HTTP 메서드
GET, POST, PUT, PATCH, DELETE가 주로 쓰입니다. 일반적으로 CRUD 방식에 매핑해서 많이 생각하고
PATCH는 PUT 방식이 전체 업데이트에만 사용해야한다는 점을 개선하기위해 나왔습니다.
그 외에 HEAD, OPTIONS 방식 등이 있습니다.

# CORS
Cross Origin Resource Sharing(교차 출처 리소스 공유)의 약자로 다른 출처의 리소스를 공유한다는 의미입니다.
이를 무조건적으로 허용하면 다른 사이트를 통해 개인정보 탈취나 공격이 가능해지기 때문에 
일반적으로 보안상의 이유로 CORS를 차단합니다.


# SOP
"같은 출처에서만 리소스를 공유할 수 있다"는 개념의 정책입니다.

# `브라우저 작동방식`
브라우저의 핵심 기능은 사용자가 선택한 웹 리소스를 서버에 요청하여 브라우저창에 표시하는 과정입니다.
이를 중점으로 작동방식에 대해 설명해보면,
1. URI를 통해 접속하면 네트워크를 통해 웹 페이지의 HTML 문서를 받아옵니다.
2. 렌더링 엔진이 해당 문서를 파싱해서 화면에 표시합니다.
    * 이 과정에서 스크립트 코드를 만나면 JavaScript 엔진에 역할이 넘어가고 이를 실행합니다.

https://web.dev/articles/howbrowserswork?hl=ko


# 쿠키, 세션의 개념과 차이
쿠키는 로컬에 저장되는 key-value 형태의 작은 데이터 파일입니다.
유효기간을 명시할 수 있고 사용자가 따로 요청하지 않아도 브라우저 요청 시 Request Header에 자동으로 서버에 전송합니다.

세션은 서버측에서 관리하는 사용자 정보 데이터입니다.
쿠키를 기반으로 하고 있지만 사용자 정보는 세션에 저장되기 때문에 보안적으로 우수합니다.
다만 서버 메모리를 많이 사용한다는 단점이 있습니다.

HTTP 통신은 상태 정보를 유지하지 않기 때문에(stateless) 
통신이 끊어져도 데이터를 유지하기 위해서는 이러한 기술들을 사용해야 합니다.

# `TCP/UDP`

TCP, UDP는 TCP/IP 모델의 전송 계층에서 데이터를 보내기 위해 사용하는 프로토콜입니다.
TCP는 신뢰성을 보장하는 연결형 서비스입니다. 
연결 지향 방식이고 3-way handshaking, 4-way handshaking 방식을 함으로써
흐름 제어나 혼잡 제어가 가능하고 신뢰성이 높습니다. 
다만 이러한 점 때문에 UDP에 비해 속도가 느립니다.

UDP는 비연결형 서비스입니다.
TCP와 다르게 데이터가 올바르게 전송되었는지 확인할 방법이 없기 때문에,
신뢰성은 떨어지고 대신 속도가 빠르고 네트워크 부하가 적습니다.

# HTTP, HTTPS
HTTP와 HTTPS의 주된 차이점은 데이터 전송 시의 보안 수준입니다. HTTPS는 HTTP에 보안 계층을 추가한 것입니다. HTTPS는 데이터가 클라이언트와 서버 간에 암호화되어 전송되므로 중간에 데이터를 가로채더라도 읽을 수 없게 만듭니다.

HTTPS의 핵심 요소 중 하나는 비대칭 키 암호화입니다. 이는 두 가지 키, 즉 공개 키와 비밀 키를 사용합니다. 공개 키는 모두에게 알려져 있고 안전하게 데이터를 암호화하는 데 사용됩니다. 반면, 비밀 키는 서버에만 저장되어 있고, 이를 통해 데이터를 복호화합니다. 클라이언트는 서버의 공개 키로 데이터를 암호화하여 전송하고, 서버는 자신의 비밀 키로 이를 복호화합니다. 이 방식은 데이터의 기밀성과 무결성을 보장합니다.
<!-- HTTP는 데이터를 주고받기 위한 프로토콜입니다. 
암호화가 되지 않은 평문 데이터를 전송하기 때문에 제3자가 이 정보를 조회할 수 있는 문제가 있었습니다. 
이를 해결하기위해 HTTPS가 등장하게 되었습니다. HTTPS는 HTTP에 SSL, TLS 보안 기술을 결합한 프로토콜입니다.
SSL, TLS은 신뢰할 수 있는 기관이 인증서를 발급해 당사자를 보증하는 방법입니다. -->

# DI, IoC
DI는 의존성 주입 이라는 의미로, 객체를 직접 생성하는 것이 아닌 외부에서 생성한 객체를 주입시켜주는 방식입니다. 
일반적으로 사용자가 직접 생성하는 것이 아닌 프레임워크를 통해 주입받기 때문에
의존성이 줄어들고, 객체간 결합도를 줄여서 재사용성을 높힐 수 있습니다.

IoC는 제어의 역전이라는 의미로, 프로그래머가 작성한 프로그램의 흐름이 외부에서 결정되는 것을 의미합니다. 이러한 패턴은 코드의 유연성을 증가시키고, 변경 및 확장을 용이하게 합니다. 스프링에서는 이를 IoC 컨테이너를 통해 구현합니다. 이는 객체 간의 의존성 관리를 컨테이너가 대신 수행하게 됩니다.

# 객체지향 프로그래밍
프로그램을 명령어의 나열이 아닌, 여러 독립된 단위인 "객체"들의 상호작용으로 보는 프로그래밍의 패러다임을 의미합니다. 
절차적 프로그래밍보다 인간 친화적이고 직관적이기 때문에
변경이 용이하고 유지보수에 유리합니다.

# 대용량 트래픽 발생 시 대응 방법
우선 서버를 확장해 로드 밸런싱을 통해 개별 서버에 부하를 줄이는 방법을 생각해 볼 수 있을 것 같습니다.
캐싱이나 DB 튜닝을 통한 데이터 최적화 방안도 생각해 볼 수 있을 것 같습니다.
특정 IP에서 오는 요청을 제한하거나 부하가 예상되는 부분을 분산처리하는 방법도 있습니다.

# ORM을 사용하면서 쿼리가 복잡해지는 경우 해결방법
우선 기본적으로 ORM이 제공하는 QueryBuilder를 사용해보는 방법이 있을 것 같습니다.
이것으로도 해결하지 못한다면 JPQL을 직접 입력하는 방법이 있을 것 같습니다.

# GET, POST 차이
GET 메서드는 데이터를 URL에 포함하여 서버에 요청하고, 주로 데이터를 가져오는 데 사용됩니다
주로 데이터를 요청할 때 사용하며 
BODY를 보내지 않기때문에 직관적이고
캐싱되어 속도가 빠릅니다.
데이터 양에도 한계가 있습니다.

반면에 POST 메서드는 데이터를 HTTP 요청 본문에 포함하여 서버에 전송하고, 주로 데이터를 제출하거나 업로드하는 데 사용됩니다.
POST는 데이터를 HTTP 메시지의 바디에 담아 보내기 때문에 더 많은 양의 정보를 안전하게 전송할 수 있습니다.
처리에 대한 규약이 약하기 때문에 다양한 처리를 할 수 있습니다.

# OSI 7 계층 - 따로정리할것
OSI 7 계층은 네트워크에서 통신이 일어나는 과정을 7단계로 나눈 것을 말합니다.

1계층 - 물리계층(Physical Layer)
2계층 - 데이터 링크계층(DataLink Layer)
3계층 - 네트워크 계층(Network Layer)
4계층 - 전송 계층(Transport Layer) 
5계층 - 세션 계층(Session Layer) 
6계층 - 표현 계층(Presentation Layer)
7계층 - 응용 계층(Application Layer)

https://shlee0882.tistory.com/110

![Alt text](img1.daumcdn.jpg)

# 세션 기반 인증과 토큰 기반 인증의 차이
세션 기반 인증은 stateful 인증 방식입니다. 이 방식에서는 사용자의 로그인 상태를 서버 측에서 관리합니다. 사용자가 로그인하면 서버는 사용자의 세션 정보를 서버의 메모리 또는 세션 데이터베이스에 저장하고, 고유한 세션 ID를 발급합니다. 사용자는 이 세션 ID를 쿠키 등을 통해 저장하고, 이후 요청마다 이 세션 ID를 서버에 전송하여 인증을 받습니다. 세션 기반 인증의 장점은 서버가 사용자 상태를 직접 관리하기 때문에 보안성이 높다는 것입니다. 그러나, 이는 서버에 부담을 주며 확장성에 제한을 받는 단점이 있습니다. 또한, 여러 서버가 있는 환경에서는 세션을 동기화하는 추가 작업이 필요합니다.

토큰 기반 인증은 stateless 인증 방식으로, 주로 JSON Web Token (JWT)을 사용합니다. 사용자가 로그인하면 서버는 사용자 정보를 기반으로 토큰을 생성하고 이를 사용자에게 반환합니다. 사용자는 이 토큰을 요청 헤더에 포함시켜 서버에 전송하고, 서버는 토큰의 유효성을 검증하여 인증합니다. 토큰에는 사용자 인증 정보와 토큰이 만료되는 시간이 포함됩니다. 이 방식의 장점은 서버가 사용자의 인증 정보를 저장할 필요가 없어 확장성이 우수하다는 것입니다. 그러나, 토큰이 탈취될 경우 보안상의 위험이 있으며, 일단 발급된 토큰은 만료되기 전까지는 유효하므로, 서버 측에서 즉시 무효화시키기 어렵습니다.
<!-- 세션 방식은 서버의 세션 저장소에 인증 정보를 넣고 이 아이디를 해더로 전송하여 인증하는 방식입니다.
해더에 ID만 넣기 때문에 트래픽은 적으나, 서버에서 인증 정보를 관리하기 때문에 서버의 부담이 커지는 것이 특징입니다.

토큰 방식은 인증 정보를 토큰으로 만들어 클라이언트에 저장하고 이 토큰을 서버로 전송하여 인증하는 방식입니다.
토큰에 인증 정보가 들어있기 때문에 네트워크 트래픽을 많이 쓰는 대신, 서버에 부담이 최소화됩니다. -->


# JWT, Refresh, Access Token
JWT(JSON Web Token)는 암호화된 토큰으로 사용자 정보를 stateless 형태로 인증합니다. 각 요청은 헤더, 페이로드, 서명을 포함해 서버에 인증 정보를 제공하며, 서버는 추가적인 인증 정보를 저장할 필요 없이 토큰만 검증하면 됩니다. 하지만 JWT의 단점 중 하나는 한 번 발급된 토큰의 정보를 서버 측에서 수정할 수 없다는 점입니다.

이를 보완하기 위해 Refresh Token이 사용됩니다. Refresh Token은 보안적으로 안전한 저장소에 보관되어 있으며, Access Token이 만료될 때 새로 발급받을 수 있게 합니다. Access Token은 짧은 시간 동안만 유효하고 자주 갱신되어 보안을 유지합니다. Refresh Token으로 인해 사용자는 불필요한 재로그인 없이 새로운 Access Token으로 로그인을 유지하면서 보안적인 장점도 가져갈 수 있습니다.
<!-- JWT (JSON Web Token)으로 사용자 인증을 하는 방식입니다. 
access token은 인증에 직접적으로 사용되는 토큰으로 만료 기간이 짧은 것이 특징입니다.
refresh token은 만료된 Access token을 갱신하는데 사용합니다. 보통 만료 기간이 길고, 서버에 저장합니다. -->

# OAuth
OAuth는 사용자의 인증 정보를 직접 공유하지 않고도 서로 다른 웹 애플리케이션 간에 안전한 인증을 제공하는 개방형 표준 프로토콜입니다. 이 표준을 통해 사용자는 한 서비스의 자격 증명을 사용하여 다른 서비스에 접근할 수 있게 되며, 이 과정에서 사용자의 비밀번호는 해당 서비스들 사이에 공유되지 않으므로 보안상 이점이 있습니다.
OAuth 작동 방식은 주로 네 가지 주체가 관련됩니다: 클라이언트, 리소스 소유자, 리소스 서버, 그리고 인증 서버. 사용자가 클라이언트 애플리케이션을 통해 어떤 서비스를 이용하고자 할 때, 리소스 소유자는 클라이언트에게 접근 권한을 부여합니다. 클라이언트는 이 권한을 인증 서버에 제출하고, 인증 서버는 클라이언트가 리소스 서버에 접근할 수 있도록 접근 토큰을 발급합니다.
이 토큰은 클라이언트가 리소스 서버에 접근할 때 사용되며, 리소스 서버는 토큰을 검증한 후 요청된 데이터에 대한 접근을 허용합니다. 이 과정 전반에서 사용자의 비밀번호나 기타 중요한 인증 정보는 직접적으로 노출되지 않으므로 보안이 유지됩니다.
<!-- 인터넷 사용자들이 비밀번호를 제공하지 않고 다른 웹사이트 상의 자신의 정보들로 
웹사이트나 어플리케이션의 접근 권한을 부여할 수 있는 개방형 기준(open standard)입니다.
현재 여러 보안상의 이슈를 해결한 OAuth2.0 이 사용되고 있습니다. -->


# 클래스형과 함수형의 차이

react 용어인 것 같은데, 컴포넌트 생성시 클래스로 구성하는지, 함수로 선언하는지의 차이입니다.
클래스형은 클래스 키워드가 필요하고 component를 상속받아야 하고 render함수가 필요한 등
불편한 사항이 많아 함수형 컴포넌트를 더 많이 사용하는 추세입니다.

# CI/CD
CI(Continuous Integration)는 개발자들이 코드 변경 사항을 중앙 리포지토리에 정기적으로 병합하도록 함으로써 통합 문제를 빠르게 발견하고 해결할 수 있게 하는 관행입니다. 이 과정에서 자동화된 빌드와 테스트가 수행되어, 모든 변경 사항이 즉시 테스트되고 주 빌드에 통합되어야 합니다. 이는 버그를 조기에 발견하여 서비스에 예상치 못한 상황이 발생하는 것을 최소화합니다.

CD(Continuous Deployment)는 테스트를 통과한 코드를 자동으로 운영 환경에 배포하는 방식입니다. 이를 통해 소프트웨어의 새로운 버전을 더 빠르고 자주 배포할 수 있으며, 사용자의 피드백을 신속하게 반영할 수 있습니다. 지속적 배포는 개발과 운영 간의 간극을 줄이고, 릴리즈 과정에서 발생할 수 있는 휴먼에러를 최소화합니다.
<!-- 지속적 통합, 지속적 배포라는 의미로 소프트웨어 통합 및 배포 프로세스를 자동화하는 것 입니다.
이를 통해 통합과 배포 과정에서 빈번하게 발생하는 문제들에 대해 신속하게 대처할 수 있고 소프트웨어에 대한 신뢰성을 높일 수 있습니다. -->

# TDD

테스트 주도 개발이라는 의미로 선 테스트 후 개발 방식의 프로그래밍 방법입니다.
테스트를 먼저 작성함으로서 설계상의 문제를 빨리 발견할 수 있으며
코드의 의도를 명확히 함으로 유지보수가 수월해집니다.
다만 생산성이 저하되고 초기 개발 시간이 길어짐으로
무조건 좋은 것은 아닙니다.

# 프로세스

운영체제로부터 자원을 할당받는 작업의 단위

# 쓰레드

프로세스가 할당받은 자원을 이용하는 실행의 단위

# 멀티 프로세스
멀티프로세스는 각 프로세스가 독립된 메모리 공간을 가지고 운영되는 방식입니다. 이 구조는 각 프로세스가 별개의 메모리를 사용하므로, 하나의 프로세스에서 발생한 오류가 다른 프로세스에 영향을 미치지 않아 안정성이 높습니다. 또한, 멀티프로세스는 병렬 실행이 가능하여 멀티코어 프로세서의 이점을 최대화할 수 있습니다. 하지만, 프로세스 간 통신은 쓰레드 간 통신에 비해 비용이 많이 듭니다.
<!-- 두개 이상 다수의 프로세서(CPU)가 협력적으로 하나 이상의 작업(Task)을 동시에 처리하는 것. (병렬처리)
Context Switching 과정에서 캐시 메모리 초기화 등 무거운 작업이 진행되고 시간이 소모되는 등 오버헤드가 발생할 수 있음 -->

# 멀티 스레드
멀티쓰레드는 하나의 프로세스 내에서 여러 쓰레드를 생성해 작업을 분배하는 방식입니다. 멀티쓰레드는 모든 쓰레드가 같은 메모리 영역을 공유하므로 데이터 공유가 간편하고, 쓰레드 간의 컨텍스트 스위칭 비용이 낮습니다.
<!-- 하나의 프로세스에 여러 스레드로 자원을 공유하며 작업을 나누어 수행
동기화 문제가 발생, 디버깅이 어려움 -->

# 쿼리 최적화 방법

1. 필요한 컬럼만 조회
2. LIKE 검색시 와일드카드는 뒤에만 사용
3. DISTINCT 사용X
4. GROUP BY 연산 시에는 가급적 HAVING보다는 WHERE 절을 사용
5. DB 값에 변환 걸기 X
6. 크기가 작은 테이블 부터 조회
7. 자주 사용하는 데이터는 전처리된 테이블에서 조회

# DB 로직 최소화

1. 적절한 캐싱 사용
    - Redis나 Memcached 사용 가능
2. 인덱싱 및 쿼리 최적화
3. 배치 처리
4. 트랜잭션 최소화
5. 데이터 정규화 및 De-normalization
6. 데이터 파티셔닝

# 테스트코드란

테스트 코드란 실제 코드가 아닌 테스트를 위한 코드를 말합니다.
기존에는 테스트 코드가 그렇게 중요하지 않았으나, 서비스 규모가 커짐에 따라
서비스의 안정성을 높히고 기능 추가, 수정에 따른 사이드이펙트에 빠르게 대응하기 위해
테스트 코드가 대두되게 되었습니다.
테스트 코드는 코드 품질 향상, 버그의 빠른 파악, 문서화 등의 효과가 있지만
개발시간이 증가하고, 유지보수 비용이 증가하며 팀원들의 학습시간이 요구되고, 
시스템의 속도저하가 발생하는 문제가 생길 수 있습니다.

# Array, LinkedList

메모리에 데이터를 저장하는 선형 데이터 구조입니다.
Array는 데이터를 연속적으로 저장하여 인덱스로 검색하는 데이터 구조이고
LinkedList는 각 요소에서 포인터를 사용하여 다음 요소에 대한 연결 정보를 포함하는 데이터 구조입니다.
Array는 요소에 접근하는 것이 쉽고 빠르지만 삭제, 삽입 작업 비용이 큽니다. 또 동적인 할당이 어렵습니다.
LinkedList는 요소에 접근하려면 첫번째 요소부터 시작해야 함으로 시간이 많이 걸리지만
각 요소에 다음 요소에 대한 정보가 포함되어 있음으로 삭제, 삽입이 간단합니다.
메모리가 런타임에 할당되므로 요구사항에 따라 동적 메모리 사용이 쉽습니다.

# AWS S3, EC2 사용 이유

s3는 스토리지, ec2는 서버를 제공해주기에 목적은 다르지만 이를 사용하는 이유는 거의 같습니다. 
클라우드 서비스로 보안, 확장성 등 개발자가 신경써야할 수많은 고민들을 해결해주기 때문이죠.

스토리지 도입을 위해 속도 테스트겸 사용해본 기억이 있습니다.


# 정렬 알고리즘

4.1. O(n²)인 것
4.1.1. 버블 정렬(Bubble sort)
4.1.1.1. 파생형
4.1.2. 선택 정렬(Selection sort)
4.1.3. 삽입 정렬(Insertion sort)
4.2. O(n log n)인 것
4.2.1. 병합 정렬/합병 정렬(Merge sort)
4.2.2. 힙 정렬(Heap sort)
4.2.3. 퀵 정렬(Quick sort)
4.2.4. 트리 정렬(Tree sort)
4.3. 하이브리드 정렬
4.3.1. 팀 정렬(Tim sort)
4.3.2. 블록 병합 정렬(Block merge sort)
4.3.3. 인트로 정렬(Intro sort)
4.4. 그 밖에
4.4.1. 기수 정렬(Radix sort)
4.4.2. 계수 정렬(Counting sort)
4.4.2.1. 실행 과정
4.4.3. 셸 정렬(Shell's sort)
4.4.4. 대기 정렬(Sleep sort)
4.4.5. 중력 정렬(Gravity sort)
4.5. 비효율적인 정렬
4.5.1. 꼭두각시 정렬(Stooge sort)
4.5.2. 보고 정렬(Bogo sort, stupid sort)
4.5.3. 보고보고 정렬(Bogobogo sort)

버블정렬 - 앞뒤 비교 a-z -> b-z 식으로 반복
선택정렬 - 가장 작은값 찾아서 제일 앞으로
삽입정렬 - 하나씩 정렬블록에 넣음으로써 정렬 블록을 넓혀감 
병합정렬 - 하나씩 쪼개서 두 그룹씩 묶으면서 병함
힙정렬 - 트리방식 정렬. 힙트리에 전부 삽입. 힙루트 탐색으로 최솟값을 찾아 루트에 옮기고, 루트값을  반환
퀵정렬 - 피봇을 하나 잡고, 피봇을 기준으로 작은값을 왼쪽, 큰값을 오른쪽으로 보냄


## 확인
* SSL과 TLS의 차이점
