<!-- 모이세스 메이세로 지음 -->

# 3. 계층 스프링 부트 애플리케이션
3계층 구조
- 클라이언트 계층 (프런트엔드)
- **어플리케이션 계층** (백엔드)
- 데이터 저장 계층

어플리케이션 계층의 3개 레이어
- 비즈니스 레이어 (개체(도메인) + 애플레키이션(서비스))
- 프레젠테이션 레이어 (컨트롤러)
- 데이터 레이어 (DAO)

이 아키텍처 패턴의 장점
- 도메인과 솔루션이 분리. (인터페이스와 데이터베이스 명세가 섞여있지않음)
- 프레젠테이션과 데이터 레이어는 다른 레이어로 교체할 수 있음.
- 레이어의 역할이 명확히 구분.

> [!warning]
> 예제와는 다르게, @SpringBootTest 남용을 권장하지 않는다.  
> 단순히 하나의 클래스를 테스트하기 위해서라면 종속성 주입이나 애플리케이션 컨택스트가 필요 없기 때문.



## 적절한 설계가 중요 (다음 순서로 제작)
- 3구조
  - 어플리케이션 계층 설계
    - 도메인
    - 비즈니스 로직 레이어
    - 프레젠테이션 레이어(REST API)
  - 클라이언트(화면) 계층 설계
  - 데이터(DAO) 계층 설계
<br>
화면과 데이터 계층 없이 서버 구성할 수 있다.

> [!tip]
> @WevMvcTest: 컨트롤러 테스트  
> @SpringBootTest: 통합 테스트

>[!tip]
> ***레포지토리를 사용할 때 TDD를 만들지 않는 이유?***  
> 
> 스프링에서 제공하는 코드(JPA Data Query)이기 떄문에, 신뢰성이 높아 굳이 단위 테스트를 작성할 필요가 없음.


> [!note]
> ***애자일과 리펙터링***  
> 
> 애자일 방법론에 따라 일하려면 리팩터링이 일의 일부임을 받아들여야함.  
> 비전과 MVP, 3~4 스프린트 등 명확히 정해야 하지만, 결국 설계와 아키텍처를 변경할 수 밖에 없게 됨.  
> 그러니 차라리 빨리 시작하고 리팩터링하는 것이 더 나음.

# 4. 마이크로서비스 시작하기
마이크로서비스는 **하지 말아야할 이유가 너무 많다!**  
그래서 **좋은 패턴의 일체형 애플리케이션 개발 후 분리하는 것을 추천!** (일체형으로 개발한 뒤 적절한 시점(일체형이 중간 규모로 커지고 관리가 어려워지기 전)에 마이크로서비스로 마이그레이션)

> [!tip]
> 애플리케이션 개선화 작업: 게임화(gamification) 기법  
> 게임에서 사용되는 기법을 적요하는 설계 프로세스.  
> 예시: 점수, 뱃지, 리더보드 추가 (github)

## 마이크로서비스 아키텍처로 전환하기
- 관심사를 분리하고 결합도 낮추기

## 마이크로서비스 연결하기
> [!note]
> 예시의 곱셈 시스템에 새로운 서비스(게임화 로직)를 추가하려면?
> 1. 두 개의 서비스가 데이터베이스를 공유하여 바로 사용
>     - 데이터가 섞이면서 컨텍스트 분리의 이점이 사라짐.
> 2. 데이터를 주기적으로 끌어오는 REST API 추가
>     - 지속적인 데이터 확인 필요, 이미 처리된 데이터 추적해야함.
> 3. 곱셈 서비스에서 무슨 일이 있을 때마다 게임화 서비스를 호출. (RPC, 원격 프로시저 호출)
>     - 가장 괜찮으나 개선여지가 있음. -> 반응형 패턴, 이벤트 중심 아키텍처


## 이벤트 중심 아키텍처
아키텍처에서 중요한 행위가 발생할 때마다 이벤트를 주고 받음(메세지 브로커).  
이런 작용-반작용 패턴을 기반으로 하는 시스템을 **반응형 시스템**이라고 함.

### 관련 기법
- 이벤트 소싱
  - 개체를 정적 상태로 모델링 하는 대신, 상태 변화를 일으키는 일련의 이벤트로 모델링하는 방식
- 도메인 주도 설계 (DDD)
- CQRS (Command-Query Responsibility Segregation)
  - 명령 쿼리 책임 분리.
  -  데이터 저장소에 대한 **읽기 및 쓰기 작업을 별도**의 데이터 모델로 분리하는 디자인 패턴

> [!tip]
> 이런 기술들은 독립적으로 적용 가능함으로, 합리적으로 사용되어야 함.  
> 기술에 현옥되지 말고 도구로 사용할 것!


### 이벤트 중심 아키텍처 장단점
- 결합도가 낮아짐
- 트랜잭션이 없음
  - 기능 요구사항을 설계하고 변환하는 방법을 변경해야함.
  - 대신 장애 허용 능력(fault tolerance)이 중요해짐
    - 예: 서비스 중 하나가 완료되지 못하더라도 전체 시스템은 멈추지 않아야함. -> 고가용성
    - 이벤트는 시스템 일부가 독립적으로 종료되고 자동으로 재시작하도록 함.
- 오케스트레이션과 모니터링
  - 중앙 집중식 오케스트레이션 계층이 없으면 모니터링이 중요한 시스템에 문제가 될 수 있음 (분산되어 있어서 따라가기 힘듬)
    - 즉 이벤트 흐름을 추적하기 위한 매커니즘, 서비스 간 상태를 기록하는 공통 로깅 시스템이 필요함
    - Zipkin 같은 툴 이용

## RabbitMQ와 스프링 AMQP를 이용한 이벤트 중심 설계
RabbitMQ 웹 사이트의 스프링 AMQP 튜토리얼 참조할 것

<br>

이벤트 모델링은 도메인 모델링 만큼 중요함.
- 꼭 필요한 정보만 담아 최대한 작고 단순하게 유지할 것.
- 일관되고 일반적인 정보를 충분히 전달할 것.

> [!note]
> 해당 소스에서, 기본 자바 직렬화 대신 JSON 직렬화를 사용 이유
> 1. 기본 직렬화는 클래스 전체 이름에 태그를 지정 -> 역직렬화 시 서비스 간 강한 결합이 생김(메세지,구독자 같은 패키지에 있어야해서)
> 2. 향후 다른 언어로 이뤄진 서비스와 연결하려면 자바 직렬화 사용 못함
> 3. 개발 초기에 사람이 읽을 수 있는 포맷이 아니라면 채널에서 발생한 에러를 분석하기 굉장히 어려움


> [!tip]
> 이벤트 클래스 추가할 떄 팁 (JSON 메세지로 변환용)
> - 이벤트 객체가 커지면 좋지 못함.
> - 객체의 변화하는 데이터를 포함시키는 것은 위험함.
>   - 소비자가 너무 많이 알게되면 안됨(종속위험).
> - 불변 값을 넣는 것이 좋음


### 이벤트 전송: 디스패처 패턴
비동기 통신의 일반적인 두 가지 패턴 - 이벤트 디스패처(발행자), 이벤트 핸들러(구독자)
- 모든 클래스에서 이벤트를 발행하고 소비하는 대신 중앙에서 이벤트 입출력 관리.
- 그러나 하나의 클래스로 처리하면 커지고 많은 리디렉션 로직으로 복잡해짐
- 하지만 마이크로서비스가 적당한 크기라면 좋음.
- 따라서 이벤트 객체가 커진다면, 마이크로서비스가 너무 클 가능성(책임 분리할 것)
- 그게 아닌데도 크다면, 이벤트 객체를 여러 클래스로 나눌 것



> [!tip]
> **도메인을 격리 상태로 유지하라!**  
> - 게임화 마이크로서비스에서 곱셈화 마이크로서비스의 도메인을 사용해야할 경우, 가장 생각하기 쉬운 해결책은 도메인 패키지를 공유할 수 있는 별도 라이브러리로 만드는 것  
> - 그러나 이 방식은 다른 마이크로서비스에서도 이 도메인을 사용할 수 있게 되면서 통제 불능 상태가 된다!(엄청난 상호 의존성이 생김)  
> - 따라서 **반드시 도메인 개체의 소유권은 하나의 마이크로서비스만**!
> - 필요하다면 어떻게해? -> 커스텀 역직렬화 전용 객체 만들기(역직렬화 구현체, DTO로 받기)!


# 5. 마이크로서비스 도구 다루기
