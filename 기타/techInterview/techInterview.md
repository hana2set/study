최빈 질문

# RDBMS 
관계형 데이터베이스의 약어로 
스키마라는 데이터 규칙을 통해 테이블이라는 표 형식에 저장하는 시스템을 의미합니다.
데이터 무결성, 일관성 등의 장점들 떄문에 데이터 관리가 쉽고 
직접 관리해야하는 파일시스템에 비해 개발비용이 현저히 적기때문에 많이 사용합니다.
다만 기본적으로 무겁고 복잡한 단점이 있고 
특히 현재 큰 데이터에 대한 빠른 처리 속도 요구에 따라 
RDBMS보다 안정성은 떨어지지만 빠른 NoSQL과 병행하여 사용하는 추세입니다. 


# nosql 
Not Only Sql의 약자로 RDB가 아닌 데이터 저장 기술을 의미합니다. 
빅데이터와 대용량 트래픽에 대응하기 위해 나왔기 때문에 데이터 일관성을 어느정도 포기하고 
정해지지않은 규격의 데이터 유형으로 저장합니다. 
대표적으로 document형태인 mongoDB, key-value 형태인 redis 등이 있습니다.
구조가 유연하고 분산 처리도 용이한 장점이 있지만 
그룹 형태로 저장하기 때문에 데이터 중복에 대한 삭제가 어렵고 (update가 느림)
명확한 데이터 구조를 보장하지 않기 때문에 구조를 결정해야할 경우 어려울 수 있습니다.


# mvc 
Model, View, Controller 로 관심사를 분리하는 디자인 패턴입니다.
model은 데이터와 비즈니스 로직을 관리하고
view는 화면 처리를 담당합니다.
controller는 해당 데이터를 전달하는 역할을 맡습니다.

# RDBMS의 정규화
데이터의 중복을 제거하고 데이터의 무결성을 유지하는 작업입니다.

# Primary Key, Foreign Key
pk는 기본키로 테이블의 각 데이터를 식별하는 용도로 사용되며 unique하며 nullable하지 않습니다.
fk는 다른테이블의 pk를 참조하는 키 입니다.

# HTTP 메서드
GET, POST, PUT, PATCH, DELETE가 주로 쓰입니다. 일반적으로 CRUD 방식에 매핑해서 많이 생각하고
PATCH는 PUT 방식이 전체 업데이트에만 사용해야한다는 점을 개선하기위해 나왔습니다.
그 외에 HEAD, OPTIONS 방식 등이 있습니다.

# CORS
Cross Origin Resource Sharing(교차 출처 리소스 공유)의 약자로 다른 출처의 리소스를 공유한다는 의미입니다.
이를 무조건적으로 허용하면 다른 사이트를 통해 개인정보 탈취나 공격이 가능해지기 때문에 
일반적으로 보안상의 이유로 CORS를 차단합니다.


# SOP
"같은 출처에서만 리소스를 공유할 수 있다"는 개념의 정책입니다.

# `브라우저 작동방식`
브라우저의 핵심 기능은 사용자가 선택한 웹 리소스를 서버에 요청하여 브라우저창에 표시하는 과정입니다.
이를 중점으로 작동방식에 대해 설명해보면,
1. URI를 통해 접속하면 네트워크를 통해 웹 페이지의 HTML 문서를 받아옵니다.
2. 렌더링 엔진이 해당 문서를 파싱해서 화면에 표시합니다.
    * 이 과정에서 스크립트 코드를 만나면 JavaScript 엔진에 역할이 넘어가고 이를 실행합니다.

https://web.dev/articles/howbrowserswork?hl=ko


# 쿠키, 세션의 개념과 차이
쿠키는 로컬에 저장되는 key-value 형태의 작은 데이터 파일입니다.
유효기간을 명시할 수 있고 사용자가 따로 요청하지 않아도 브라우저 요청 시 Request Header에 자동으로 서버에 전송합니다.

세션은 서버측에서 관리하는 사용자 정보 데이터입니다.
쿠키를 기반으로 하고 있지만 사용자 정보는 세션에 저장되기 때문에 보안적으로 우수합니다.
다만 서버 메모리를 많이 사용한다는 단점이 있습니다.

HTTP 통신은 상태 정보를 유지하지 않기 때문에(stateless) 
통신이 끊어져도 데이터를 유지하기 위해서는 이러한 기술들을 사용해야 합니다.

# `TCP/UDP`

TCP, UDP는 TCP/IP 모델의 전송 계층에서 데이터를 보내기 위해 사용하는 프로토콜입니다.
TCP는 신뢰성을 보장하는 연결형 서비스입니다. 
연결 지향 방식이고 3-way handshaking, 4-way handshaking 방식을 함으로써
흐름 제어나 혼잡 제어가 가능하고 신뢰성이 높습니다. 
다만 이러한 점 때문에 UDP에 비해 속도가 느립니다.

UDP는 비연결형 서비스입니다.
TCP와 다르게 데이터가 올바르게 전송되었는지 확인할 방법이 없기 때문에,
신뢰성은 떨어지고 대신 속도가 빠르고 네트워크 부하가 적습니다.

# HTTP, HTTPS

HTTP는 데이터를 주고받기 위한 프로토콜입니다. 
암호화가 되지 않은 평문 데이터를 전송하기 때문에 제3자가 이 정보를 조회할 수 있는 문제가 있었습니다. 
이를 해결하기위해 HTTPS가 등장하게 되었습니다. HTTPS는 HTTP에 SSL, TLS 보안 기술을 결합한 프로토콜입니다.
SSL, TLS은 신뢰할 수 있는 기관이 인증서를 발급해 당사자를 보증하는 방법입니다.

# DI, IoC
DI는 의존성 주입 이라는 의미로, 객체를 직접 생성하는 것이 아닌 외부에서 생성한 객체를 주입시켜주는 방식입니다. 
일반적으로 사용자가 직접 생성하는 것이 아닌 프레임워크를 통해 주입받기 때문에
의존성이 줄어들고, 객체간 결합도를 줄여서 재사용성을 높힐 수 있습니다.

IoC는 제어의 역전이라는 의미로, 프로그래머가 작성한 프로그램의 흐름이 외부에서 결정되는 것을 의미합니다. 
이를 통해 개발자가 비즈니스 로직에 집중할 수 있습니다.

# 객체지향 프로그래밍
프로그램을 명령어의 나열이 아닌, 여러 독립된 단위인 "객체"들의 상호작용으로 보는 프로그래밍의 패러다임을 의미합니다. 
절차적 프로그래밍보다 인간 친화적이고 직관적이기 때문에
변경이 용이하고 유지보수에 유리합니다.

# 대용량 트래픽 발생 시 대응 방법
우선 서버를 확장해 로드 밸런싱을 통해 개별 서버에 부하를 줄이는 방법을 생각해 볼 수 있을 것 같습니다.
캐싱이나 DB 튜닝을 통한 데이터 최적화 방안도 생각해 볼 수 있을 것 같습니다.
특정 IP에서 오는 요청을 제한하거나 부하가 예상되는 부분을 분산처리하는 방법도 있습니다.

# ORM을 사용하면서 쿼리가 복잡해지는 경우 해결방법
우선 기본적으로 ORM이 제공하는 QueryBuilder를 사용해보는 방법이 있을 것 같습니다.
이것으로도 해결하지 못한다면 JPQL을 직접 입력하는 방법이 있을 것 같습니다.

# GET, POST 차이
GET 방식은 URL에 필요한 정보를 포함해 요청을 보냅니다.
주로 데이터를 요청할 때 사용하며 
BODY를 보내지 않기때문에 직관적이고
캐싱되어 속도가 빠릅니다.
데이터 양에도 한계가 있습니다
POST 방식은 URL이 아닌 BODY에 필요한 정보를 담습니다.
좀더 보안적이고 처리에 대한 규약이 약하기 때문에
다양한 처리를 할 수 있습니다.
주로 리소스 생성에 많이 사용합니다.

# OSI 7 계층 - 따로정리할것
OSI 7 계층은 네트워크에서 통신이 일어나는 과정을 7단계로 나눈 것을 말합니다.

1계층 - 물리계층(Physical Layer)
2계층 - 데이터 링크계층(DataLink Layer)
3계층 - 네트워크 계층(Network Layer)
4계층 - 전송 계층(Transport Layer) 
5계층 - 세션 계층(Session Layer) 
6계층 - 표현 계층(Presentation Layer)
7계층 - 응용 계층(Application Layer)

https://shlee0882.tistory.com/110

![Alt text](img1.daumcdn.jpg)

# 세션 기반 인증과 토큰 기반 인증의 차이

세션 방식은 서버의 세션 저장소에 인증 정보를 넣고 이 아이디를 해더로 전송하여 인증하는 방식입니다.
해더에 ID만 넣기 때문에 트래픽은 적으나, 서버에서 인증 정보를 관리하기 때문에 서버의 부담이 커지는 것이 특징입니다.

토큰 방식은 인증 정보를 토큰으로 만들어 클라이언트에 저장하고 이 토큰을 서버로 전송하여 인증하는 방식입니다.
토큰에 인증 정보가 들어있기 때문에 네트워크 트래픽을 많이 쓰는 대신, 서버에 부담이 최소화됩니다.


# JWT, Refresh, Access Token

JWT (JSON Web Token)으로 사용자 인증을 하는 방식입니다. 
access token은 인증에 직접적으로 사용되는 토큰으로 만료 기간이 짧은 것이 특징입니다.
refresh token은 만료된 Access token을 갱신하는데 사용합니다. 보통 만료 기간이 길고, 서버에 저장합니다.

# OAuth

인터넷 사용자들이 비밀번호를 제공하지 않고 다른 웹사이트 상의 자신의 정보들로 
웹사이트나 어플리케이션의 접근 권한을 부여할 수 있는 개방형 기준(open standard)입니다.
현재 여러 보안상의 이슈를 해결한 OAuth2.0 이 사용되고 있습니다.


# 클래스형과 함수형의 차이

react 용어인 것 같은데, 컴포넌트 생성시 클래스로 구성하는지, 함수로 선언하는지의 차이입니다.
클래스형은 클래스 키워드가 필요하고 component를 상속받아야 하고 render함수가 필요한 등
불편한 사항이 많아 함수형 컴포넌트를 더 많이 사용하는 추세입니다.

# CI/CD

지속적 통합, 지속적 배포라는 의미로 소프트웨어 통합 및 배포 프로세스를 자동화하는 것 입니다.
이를 통해 통합과 배포 과정에서 빈번하게 발생하는 문제들에 대해 신속하게 대처할 수 있고 소프트웨어에 대한 신뢰성을 높일 수 있습니다.

# TDD

테스트 주도 개발이라는 의미로 선 테스트 후 개발 방식의 프로그래밍 방법입니다.
테스트를 먼저 작성함으로서 설계상의 문제를 빨리 발견할 수 있으며
코드의 의도를 명확히 함으로 유지보수가 수월해집니다.
다만 생산성이 저하되고 초기 개발 시간이 길어짐으로
무조건 좋은 것은 아닙니다.

# 프로세스

운영체제로부터 자원을 할당받는 작업의 단위

# 쓰레드

프로세스가 할당받은 자원을 이용하는 실행의 단위

# 멀티 프로세스

두개 이상 다수의 프로세서(CPU)가 협력적으로 하나 이상의 작업(Task)을 동시에 처리하는 것. (병렬처리)
Context Switching 과정에서 캐시 메모리 초기화 등 무거운 작업이 진행되고 시간이 소모되는 등 오버헤드가 발생할 수 있음

# 멀티 스레드

하나의 프로세스에 여러 스레드로 자원을 공유하며 작업을 나누어 수행
동기화 문제가 발생, 디버깅이 어려움

# 쿼리 최적화 방법

1. 필요한 컬럼만 조회
2. LIKE 검색시 와일드카드는 뒤에만 사용
3. DISTINCT 사용X
4. GROUP BY 연산 시에는 가급적 HAVING보다는 WHERE 절을 사용
5. DB 값에 변환 걸기 X
6. 크기가 작은 테이블 부터 조회
7. 자주 사용하는 데이터는 전처리된 테이블에서 조회

# DB 로직 최소화

1. 적절한 캐싱 사용
    - Redis나 Memcached 사용 가능
2. 인덱싱 및 쿼리 최적화
3. 배치 처리
4. 트랜잭션 최소화
5. 데이터 정규화 및 De-normalization
6. 데이터 파티셔닝

# 테스트코드란

테스트 코드란 실제 코드가 아닌 테스트를 위한 코드를 말합니다.
기존에는 테스트 코드가 그렇게 중요하지 않았으나, 서비스 규모가 커짐에 따라
서비스의 안정성을 높히고 기능 추가, 수정에 따른 사이드이펙트에 빠르게 대응하기 위해
테스트 코드가 대두되게 되었습니다.
테스트 코드는 코드 품질 향상, 버그의 빠른 파악, 문서화 등의 효과가 있지만
개발시간이 증가하고, 유지보수 비용이 증가하며 팀원들의 학습시간이 요구되고, 
시스템의 속도저하가 발생하는 문제가 생길 수 있습니다.

# Array, LinkedList

메모리에 데이터를 저장하는 선형 데이터 구조입니다.
Array는 데이터를 연속적으로 저장하여 인덱스로 검색하는 데이터 구조이고
LinkedList는 각 요소에서 포인터를 사용하여 다음 요소에 대한 연결 정보를 포함하는 데이터 구조입니다.
Array는 요소에 접근하는 것이 쉽고 빠르지만 삭제, 삽입 작업 비용이 큽니다. 또 동적인 할당이 어렵습니다.
LinkedList는 요소에 접근하려면 첫번째 요소부터 시작해야 함으로 시간이 많이 걸리지만
각 요소에 다음 요소에 대한 정보가 포함되어 있음으로 삭제, 삽입이 간단합니다.
메모리가 런타임에 할당되므로 요구사항에 따라 동적 메모리 사용이 쉽습니다.

# AWS S3, EC2 사용 이유

s3는 스토리지, ec2는 서버를 제공해주기에 목적은 다르지만 이를 사용하는 이유는 거의 같습니다. 
클라우드 서비스로 보안, 확장성 등 개발자가 신경써야할 수많은 고민들을 해결해주기 때문이죠.

스토리지 도입을 위해 속도 테스트겸 사용해본 기억이 있습니다.


# 정렬 알고리즘

4.1. O(n²)인 것
4.1.1. 버블 정렬(Bubble sort)
4.1.1.1. 파생형
4.1.2. 선택 정렬(Selection sort)
4.1.3. 삽입 정렬(Insertion sort)
4.2. O(n log n)인 것
4.2.1. 병합 정렬/합병 정렬(Merge sort)
4.2.2. 힙 정렬(Heap sort)
4.2.3. 퀵 정렬(Quick sort)
4.2.4. 트리 정렬(Tree sort)
4.3. 하이브리드 정렬
4.3.1. 팀 정렬(Tim sort)
4.3.2. 블록 병합 정렬(Block merge sort)
4.3.3. 인트로 정렬(Intro sort)
4.4. 그 밖에
4.4.1. 기수 정렬(Radix sort)
4.4.2. 계수 정렬(Counting sort)
4.4.2.1. 실행 과정
4.4.3. 셸 정렬(Shell's sort)
4.4.4. 대기 정렬(Sleep sort)
4.4.5. 중력 정렬(Gravity sort)
4.5. 비효율적인 정렬
4.5.1. 꼭두각시 정렬(Stooge sort)
4.5.2. 보고 정렬(Bogo sort, stupid sort)
4.5.3. 보고보고 정렬(Bogobogo sort)

버블정렬 - 앞뒤 비교 a-z -> b-z 식으로 반복
선택정렬 - 가장 작은값 찾아서 제일 앞으로
삽입정렬 - 하나씩 정렬블록에 넣음으로써 정렬 블록을 넓혀감 
병합정렬 - 하나씩 쪼개서 두 그룹씩 묶으면서 병함
힙정렬 - 트리방식 정렬. 힙트리에 전부 삽입. 힙루트 탐색으로 최솟값을 찾아 루트에 옮기고, 루트값을  반환
퀵정렬 - 피봇을 하나 잡고, 피봇을 기준으로 작은값을 왼쪽, 큰값을 오른쪽으로 보냄


## 확인
* SSL과 TLS의 차이점
