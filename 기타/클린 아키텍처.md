<!-- 클린 아키텍처
소프트웨어 구조와 설계의 원칙
로버트 C.마틴 지음 -->

ancle bob's Clean Architecture
![image](https://github.com/hana2set/study/assets/97689567/70846850-f5f0-4b20-b085-1c745fdee1e9)

### DIP
* 하위 모듈의 수정이 있으면 상위 모듈도 변경될 가능성이 높음.
* 상위 모듈을 직접참조 X -> 설계도(interface)를 참조하도록 설계
    * 이유 : 변화가 거의 없는 모듈을 참조하기 위해!


### 테스트 코드는 시스템의 일부
* 잘못 설계된 테스트는 깨지기 쉽고 유지보수하기 어려워짐.
* 결국 폐기되기에 잘 설계되어야 함.

### 클린 임베디드 아키텍처
* 하드웨어와 펌웨어 변경이 소프트웨어 변경보다 빠름
    * "잘 동작함"도 중요하지만 클린하게 짜는 것 또한 중요성이 낮지 않다. 소프트웨어에 수명과 관계가 있기 때문.
    * 잘 설계하지 않으면 소프트웨어는 펌웨어가 됨 -> 경계를 철저히 하자
    
* 타깃-하드웨어 병목현상
    * 하드웨어가 없거나, 부족하거나, 자체 버그가 있을 수 있음. 이에 따라 소프트웨어 개발이 더 느리게 진행됨
    * 테스트하기 쉬운 코드 = 클린 임베디드 아키텍쳐
        * 계층을 잘 분할해야함.
            * "OS > 소프트웨어 > 펌웨어 > 하드웨어" 처럼 격리 가능하게 개발하고 경계를 잘 설정해야함 (HAL, OSAL) 
            * 섞이면 아래 단계에 종속되어 버림으로 주의. 
                > 소프트웨어에서 펌웨어 코드를 직접 사용 -> 소프트웨어가 펌웨어에 종속 == 펌웨어 계층
            

### 시스템의 초기 아키텍처 결정 순서
* 액터와 유스케이스
* 컴포넌트 아키텍처
    * 저수준의 세부사항에서 발생한 변경이 상위로 파급되지 않도록 개방 폐쇄 원칙을 적용. 
        
## 세부 사항 - 저수준의 관심사
* 데이터베이스
    * DB는 일개 소프트웨어일 뿐이다. 중요한 것은 "데이터"
    * 유틸리티일 뿐임으로 시스템 아키텍처를 오염시켜서는 안된다.
    * RDBMS가 대세인 이유는 유행. 언제나 바뀔 수 있다.
* 웹
    * 웹은 GUI. 업무 규칙으로 부터 분리되어야 한다.
* 프레임워크
    * 사용할 수는 있으나, __결합해서는 안됨__.
        * 프레임워크의 진화방향이 프로그램과 맞지 않을 수 있음.
        * 더 나은 프레임워크의 등장
        * 프레임워크의 틀을 벗어나기 쉽지않음.
    * 예시 : Spring - autowired
        * 업무 객체 도처에 산재해서는 안됨! ( 업무 객체가 스프링에 대해 몰라야함)
    * 결합해야할 수도 있으나, 최대한 선택적으로! (자바의 표준 라이브러리 등. 가급적 경계 너머로 설정해야함.)

<br>

## 코드 조직화 관련 설계 방식 (패키지 구조)
![image](https://github.com/hana2set/study/assets/97689567/0cc7bdf5-8537-4133-9d07-cb28fcdeb1c4)

### 계층 기반 패키지(수평 계층형 아키텍처)
* 기술적인 관점에서 코드가 하는 일에 기반해 그 코드를 분할함.
* 우리가 스프링에서 일반적으로 쓰는 구조 (controller, service, domain)
* 복잡하지 않고 간단하게 설계가 가능하나, __업무 도메인에 대해 아무것도 말해주지 않음.__ -> 복잡해지면 문제 발생


### 기능 기반 패키지(수직 계층형 아키텍처)
* 계층 기반 패키지의 간단한 리펙터링 형태
* 상위 수준 구조가 도메인에 대한 무언가를 알려줌.
* 패키지 밖 코드들이 컨트롤러를 통하지 않으면 업무 규칙에 접근할 수 없음! -> 맞을 때도, 틀릴 때도 있다.
<br><br>
    > __계층형 아키텍처의 문제__
    >    * 다른 패키지에 있어서 public 키워드가 강제됨
    >    * 규칙을 "강제" 해야하는 부분이 생김
    >        * 아래 계층에 의존해야 하지만 신규 개발자가 잘못 사용할 수 있음. (controller에서 바로 repository 호출) 이를 막으려면 결국 팀의 원칙을 세워야 하지만 언제 어긋날 지 알 수 없음.(납기가 다가온다거나..)
    >        * 정적 분석 도구(NDepend, Structure101, checkstyle) 추천하나, 문제를 발견하는 주기가 필요 이상으로 길다.

### 컴포넌트 기반 패키지 (저자가 새로 주장함)
* 수직 계층형 아키텍처랑 비슷하나, 주문과 관련된 업무 규칙을 한 곳에서 처리하도록 한듯 (services -> component)
* protected 접근지시자 사용 -> 외부로부터 repository 보호 가능
* "포트와 어댑터" 혹은 "육각형 아키텍처" 형태로 구성 가능
<br>
    > 포트와 어댑터 (맨 위 그림 참조)
    >   * 내부(도메인)과 외부(인프라)로 구분
    >   * 외부가 내부에 의존해야함

### 기타 구조
* java 9 모듈부터 외부에 공표할 타입 분리 가능(public 이더라도 타입 외 사용 불가)
* 소스 트리를 물리적으로 분리 (이상적이기는 하나 나누다 보면 성능, 복잡성, 유지보수 등이 어려워질 수 있음) -> 예시: "도메인 // 인프라" 소스 분리 (포트, 어뎁터 패턴)
    

<br><br>

단어<br>
SOLID, REP, CCP, CRP, CQRS

<br>

이미지 출처
* https://hwannny.tistory.com/52
* https://medium.com/swlh/clean-architecture-a-little-introduction-be3eac94c5d1
